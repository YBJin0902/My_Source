/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : TouchGFXHAL.cpp
  ******************************************************************************
  * This file is generated by TouchGFX Generator 4.19.1.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

#include <TouchGFXHAL.hpp>

/* USER CODE BEGIN TouchGFXHAL.cpp */

#include "stm32f4xx_hal.h"
#include <touchgfx/hal/OSWrappers.hpp>
#include <STM32TouchController.hpp>
#include "main.h"

#include <touchgfx/hal/GPIO.hpp>
#include <CortexMMCUInstrumentation.hpp>
#include "FreeRTOS.h"
#include "task.h"

void initLCD(void);
void setWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Xwidth, uint16_t Height);

volatile bool firstFrameReadyToDisplay = false;
static volatile bool refreshRequested = false;
static volatile bool displayRefreshing = false;
static uint16_t* currFbBase = 0;

extern "C"
{
    void LCD_IO_WriteReg(uint8_t Reg);        //defined in TouchGFXGeneratedHAL.cpp
    void LCD_IO_WriteData(uint16_t RegValue); //defined in TouchGFXGeneratedHAL.cpp
}

using namespace touchgfx;

static CortexMMCUInstrumentation mcuInstr;

void TouchGFXHAL::initialize()
{
    // Calling parent implementation of initialize().
    //
    // To overwrite the generated implementation, omit call to parent function
    // and implemented needed functionality here.
    // Please note, HAL::initialize() must be called to initialize the framework.

    initLCD();

    TouchGFXGeneratedHAL::initialize();

    lockDMAToFrontPorch(false);

    mcuInstr.init();
    setMCUInstrumentation(&mcuInstr);
    enableMCULoadCalculation(true);
}

uint16_t* TouchGFXHAL::getTFTFrameBuffer() const
{
    return currFbBase;
}

void TouchGFXHAL::setTFTFrameBuffer(uint16_t* adr)
{
    currFbBase = adr;

    TouchGFXGeneratedHAL::setTFTFrameBuffer(adr);
}

void TouchGFXHAL::configureInterrupts()
{
}

void TouchGFXHAL::enableLCDControllerInterrupt()
{
}

void TouchGFXHAL::disableInterrupts()
{
}

void TouchGFXHAL::enableInterrupts()
{
}

void TouchGFXHAL::flushFrameBuffer()
{
    TouchGFXGeneratedHAL::flushFrameBuffer();
}

void  TouchGFXHAL::flushFrameBuffer(const Rect& rect)
{
    TouchGFXGeneratedHAL::flushFrameBuffer(rect);
}

bool TouchGFXHAL::blockCopy(void* RESTRICT          dest,
                            const void* RESTRICT    src,
                            uint32_t            numBytes)
{
    return TouchGFXGeneratedHAL::blockCopy(dest, src, numBytes);
}

bool TouchGFXHAL::beginFrame()
{
    refreshRequested = false;

    return TouchGFXGeneratedHAL::beginFrame();
}

void TouchGFXHAL::endFrame()
{
    TouchGFXGeneratedHAL::endFrame();

    if (frameBufferUpdatedThisFrame)
    {
        refreshRequested = true;
    }
}

void LCD_SignalTearingEffectEvent(void)
{
    // VSync has occurred, increment TouchGFX engine vsync counter
    HAL::getInstance()->vSync();
    // VSync has occurred, signal TouchGFX engine
    OSWrappers::signalVSync();

    if (refreshRequested && !displayRefreshing)
    {
        // Swap frame buffers immediately instead of waiting for the task to be scheduled in.
        // Note: task will also swap when it wakes up, but that operation is guarded and will not have
        // any effect if already swapped.

        touchgfx::HAL::getInstance()->swapFrameBuffers();

        displayRefreshing = true;

        // Set window, enable display reading to GRAM, transmit buffer using DMA
        setWindow(0, 0, 240, 240);
        LCD_IO_WriteReg(ST7789H2_WRITE_RAM);

        for (int i = 0; i < 240 * 240; i++)
        {
            LCD_IO_WriteData(currFbBase[i]);
        }

        displayRefreshing = false;
    }
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == LCD_TE_Pin)
    {
        uint8_t PinStatus = (HAL_GPIO_ReadPin(LCD_TE_GPIO_Port, LCD_TE_Pin) == GPIO_PIN_SET ? 1 : 0);

        if (PinStatus) // Raising edge : entering Active Area
        {
            GPIO::set(GPIO::VSYNC_FREQ);

            LCD_SignalTearingEffectEvent();
        }
        else // Falling edge : exiting active area
        {
            GPIO::clear(GPIO::VSYNC_FREQ);
        }
    }
    if (GPIO_Pin == TS_INT_Pin)
    {
        // Touch input is read by interrupt based on external pin interrupt from touch controller
        readTouchInput();
    }
}

void initLCD(void)
{
    /* Reset ST7789H2 */
    HAL_GPIO_WritePin(LCD_RESET_GPIO_Port, LCD_RESET_Pin, GPIO_PIN_RESET);
    HAL_Delay(1); /* wait at least 10us according ST7789H2 datasheet */
    HAL_GPIO_WritePin(LCD_RESET_GPIO_Port, LCD_RESET_Pin, GPIO_PIN_SET);
    HAL_Delay(120); /* wait maximum 120ms according ST7789H2 datasheet */

    /* Init display */
    LCD_IO_WriteReg(ST7789H2_COLOR_MODE);
    LCD_IO_WriteData(ST7789H2_FORMAT_RBG565);
    LCD_IO_WriteReg(ST7789H2_DISPLAY_INVERSION_ON);

    /* Voltage Gamma Control */
    const uint8_t arrayLength = 14;
    const uint16_t PVparameters[arrayLength] = {0x00D0, 0x0008, 0x0011, 0x0008, 0x000C, 0x0015, 0x0039, 0x0033, 0x0050, 0x0036, 0x0013, 0x0014, 0x0029, 0x002D};
    const uint16_t NVparameters[arrayLength] = {0x00D0, 0x0008, 0x0010, 0x0008, 0x0006, 0x0006, 0x0039, 0x0044, 0x0051, 0x000B, 0x0016, 0x0014, 0x002F, 0x0031};
    LCD_IO_WriteReg(ST7789H2_PV_GAMMA_CTRL);
    for (uint32_t i = 0; i < arrayLength; i++)
    {
        LCD_IO_WriteData(PVparameters[i]);
    }
    LCD_IO_WriteReg(ST7789H2_NV_GAMMA_CTRL);
    for (uint32_t i = 0; i < arrayLength; i++)
    {
        LCD_IO_WriteData(NVparameters[i]);
    }

    /* Fill with black pixels */
    LCD_IO_WriteReg(ST7789H2_WRITE_RAM);
    for (uint32_t i = 0; i < 240 * 240; i++)
    {
        LCD_IO_WriteData(0x0000);
    }

    /* Display on */
    LCD_IO_WriteReg(ST7789H2_DISPLAY_ON);
    LCD_IO_WriteReg(ST7789H2_SLEEP_OUT);

    /* Tearing effect line on */
    LCD_IO_WriteReg(ST7789H2_TE_LINE_ON);
    LCD_IO_WriteData(0x00); // TE Mode 1

    /* Backlight control signal assertion */
    HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_Port, LCD_BL_CTRL_Pin, GPIO_PIN_SET);
}

void setWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Xwidth, uint16_t Height)
{
    // Set pixel x pos:
    LCD_IO_WriteReg(ST7789H2_CASET);
    LCD_IO_WriteData(Xpos >> 8);                   /* XS[15:8] */
    LCD_IO_WriteData((uint8_t)Xpos);               /* XS[7:0] */
    LCD_IO_WriteData((Xpos + Xwidth - 1) >> 8);        /* XE[15:8] */
    LCD_IO_WriteData((uint8_t)(Xpos + Xwidth - 1));    /* XE[7:0] */


    // Set pixel y pos:
    LCD_IO_WriteReg(ST7789H2_RASET);
    LCD_IO_WriteData(Ypos >> 8);                 /* YS[15:8] */
    LCD_IO_WriteData((uint8_t)Ypos);             /* YS[7:0] */
    LCD_IO_WriteData((Ypos + Height - 1) >> 8);        /* YE[15:8] */
    LCD_IO_WriteData((uint8_t)(Ypos + Height - 1));    /* YE[7:0] */
}

extern "C" {

    portBASE_TYPE IdleTaskHook(void* p)
    {
        if ((int)p) //idle task sched out
        {
            touchgfx::HAL::getInstance()->setMCUActive(true);
        }
        else //idle task sched in
        {
            touchgfx::HAL::getInstance()->setMCUActive(false);
        }
        return pdTRUE;
    }
}

/* USER CODE END TouchGFXHAL.cpp */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
